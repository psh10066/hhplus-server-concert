# 동시성 제어 방식 분석 보고서

## 개요

유저의 잔고 충전/사용과 콘서트 예약에 대해 동시성 제어를 수행합니다.  
`UserServiceConcurrencyIT`와 `ReservationFacadeConcurrencyIT`를 통해 동시성 문제가 발생할 수 있는 코드 부분을 확인하고, 이를 해결하기 위한 방법을 제시합니다.

---

## UserServiceConcurrencyIT

- 잔고 충전/사용 시 유저 지갑(`user_wallet`) 테이블의 비관적 락을 통해 동시성 제어를 수행합니다.
- 돈과 관련된 데이터는 정합성을 보장해야 하므로 비관적 락을 사용합니다.
- `UserService`의 `charge` 및 `use` 메서드는 모두 트랜잭션 내에서 수행되며, 트랜잭션 내에서 락을 획득한 상태에서 수행됩니다.

---

## `ReservationFacadeConcurrencyIT`

- 콘서트 예약 시 콘서트 좌석(`concert_seat`) 테이블의 비관적 락을 통해 동시성 제어를 수행합니다.

#### 기존 구조에서 동시성 처리를 수행하는 경우 문제점

- 기존 구조에서는 콘서트 별로 콘서트 일정과 콘서트 좌석이 각각 존재하고, 일정과 좌석을 조합하여 예약하는 방식이었으나, 해당 방식에서 동시성 제어를 수행하는 경우 아래와 같은 문제점이 있었습니다. (기본적으로 일정 및 좌석 ID는 복합 인덱스로 관리하는 것을 전제)
    1. 최초 예약 테이블에서 콘서트 일정 ID와 콘서트 좌석 ID를 통해 Lock을 시도하는 경우 : 예약 정보가 추가되어있지 않기 때문에 Lock이 수행되지 않습니다.
    2. where 조건에서 콘서트 일정 ID를 equals로 잡은 후 해당하는 좌석 ID에 대해서 Gap Lock을 시도하는 경우 : MySQL의 supremum lock이 발생하여 콘서트 좌석 ID가 더 큰 row들에 대해서 Next Key Lock이 걸리는 문제가 있습니다.
        - [참고 자료](https://medium.com/daangn/mysql-gap-lock-%EB%91%90%EB%B2%88%EC%A7%B8-%EC%9D%B4%EC%95%BC%EA%B8%B0-49727c005084)
    3. MySQL의 isolation Level이 `REPEATABLE_READ`이고, 해당 컬럼들에 index가 아예 걸려있지 않은 경우 : Lock을 시도할 때 테이블 풀스캔이 일어나 동시성 처리가 성공하는 경우가 있으나, 해당 경우는 심각한 성능 저하를 유발할 수 있습니다.
- 위의 방법 중에서 2번 방법이 가장 현실적인 해결방안이 될 수 있겠으나, 언급한 대로 의도치 않은 row에 Lock이 걸려 성능 저하를 유발할 수 있습니다.

#### 해결 과정

- 콘서트 별로 콘서트 일정과 콘서트 좌석이 각각 존재하는 것이 아닌, **콘서트 일정 기반으로 콘서트 좌석을 각각 관리하는 방향으로 개념을 변경**합니다.
  - 이는 멘토링 시간에 얻은 패러다임의 전환 방식으로, 각 콘서트 일정의 예약 시 해당 좌석이 선점되어있는지 여부를 콘서트 좌석이 단독으로 관리할 수 있게 됩니다.
  - 따라서 해당 좌석은 기본적으로 row가 생성되어 있어 PK를 통해 해당 좌석 테이블에서 비관적 락을 획득할 수 있습니다.
  - 이러한 방식으로 예약 시 콘서트 좌석 테이블에서 비관적 락을 획득하고, 예약 정보를 추가하는 방식으로 동시성 제어를 수행합니다.

#### 고려 사항

- 콘서트 좌석의 도메인에 현재 예약 상태값을 추가하게 되면 아래와 같은 문제가 있습니다.
  - 조건 쿼리 및 예약/결제 대응 등 기존 구조의 많은 수정이 불가피합니다.
  - 5분 이후 예약이 만료되는 경우 예약 상태값을 예약 취소로 변경이 되어야 하나, 스케줄러를 통해 예약 만료 시 예약 취소 로직을 수행하는 경우 정확히 5분을 대응하기 어려운 문제가 있습니다.
  - 이를 대응하기 위해 현재의 예약 도메인에서처럼 만료 시간을 두기에는 콘서트 좌석의 개념과 거리가 가깝지 않은 것으로 보입니다.

#### 해결 방안

- 위에서 언급한 대로, DB만으로 정확한 5분을 대응하기 위해 예약 테이블에서 만료 시간을 두고 5분이 지난 row는 무시하는 방향으로 개발되어 있습니다.
  - 세부 구현 방식 : 좌석에 대한 비관적 락 수행 후 예약 목록을 조회하여 만료되지 않은 예약이 하나라도 있는지 확인
  - 위의 방식은 MySQL의 isolation Level이 `REPEATABLE_READ`인 경우, 첫 예약이 성공된 후에서의 다른 트랜잭션에서도 예약 목록 조회 시 목록에 첫 예약이 나타나지 않아서 유효성 검사 로직을 통과하는 문제가 있습니다.
  - 따라서 결제 로직 내에서 **MySQL의 isolation Level을 `READ_COMMITTED`로 설정하여 해결**하였습니다.